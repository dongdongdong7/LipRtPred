% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LipRtPred_MD.R
\name{smartsMatch}
\alias{smartsMatch}
\alias{.smartsMatch}
\alias{C_C_count}
\alias{.C_C_count}
\alias{.searchCOO}
\alias{.cal_c}
\alias{.cal_d}
\alias{.cal_h}
\alias{.cal_n}
\title{LipRtPred Molecule Descriptors}
\usage{
smartsMatch(smiles, SMARTS)

.smartsMatch(smiles, SMARTS, scriptPath)

C_C_count(smi, start_atom_idx, end_atom_idx)

.C_C_count(smi, start_atom_idx, end_atom_idx, scriptPath)

.searchCOO(smi, min_C = 1, max_C = 24, scriptPath)

.cal_c(smi, min_C = 1, max_C = 24, scriptPath)

.cal_d(smi, min_C = 1, max_C = 24, scriptPath)

.cal_h(smi, min_C = 1, max_C = 24, scriptPath)

.cal_n(smi, min_C = 1, max_C = 24, max_OH = 5, scriptPath)
}
\arguments{
\item{smiles}{smiles vector}

\item{SMARTS}{SMARTS pattern}

\item{smi}{A SMILES string}

\item{start_atom_idx}{The index of start atom}

\item{end_atom_idx}{The index of end atom}

\item{min_C}{Minimum value of C-chain length to be considered}

\item{max_C}{Maximum value of C-chain length to be considered}
}
\value{
A list.

Atom number.
}
\description{
Calculate LipRtPred MD using RDKit package with SMARTS rules.
}
\details{
\code{smartsMatch()} function is used to find the SMARTS pattern.\cr
\code{C_C_count()} function can calculate the atom number between two C atom.
}
\examples{
smartsMatch(smiles = c("CC(O)CC(O)C", "C(O)CC(O)C"), SMARTS = "CO")
.smartsMatch(smiles = c("CC(O)CC(O)C", "C(O)CC(O)C"), SMARTS = "CO",
             scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
draw_smiles(smiles = "C(O)(=O)CC(O)C/C=C\\\\C/C=C\\\\C/C=C\\\\C/C=C\\\\CCCCC", SMARTS = "[CX3;$(C=O);$(C-O)](=O)O", subImgSize = c(800, 800))
smartsMatch(smiles = "C(O)(=O)CC(O)C/C=C\\\\C/C=C\\\\C/C=C\\\\C/C=C\\\\CCCCC", SMARTS = "[CX3;$(C=O);$(C-O)](=O)O")
C_C_count("C(O)(=O)CC(O)C/C=C\\\\C/C=C\\\\C/C=C\\\\C/C=C\\\\CCCCC", start_atom_idx = 0, end_atom_idx = 7)
.C_C_count("C(O)(=O)CC(O)C/C=C\\\\C/C=C\\\\C/C=C\\\\C/C=C\\\\CCCCC", start_atom_idx = 0, end_atom_idx = 7,
           scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
.searchCOO(smi = "C(OC(=O)CCCCCCCCCCCCCCCCC)[C@]([H])(OC(CCCCCCCCCCCCCCC)=O)COC(CCCCCCCCCCC)=O",
           scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
.cal_c(smi = "C(OC(=O)CCCCCCCCCCCCCCCCC)[C@]([H])(OC(CCCCCCCCCCCCCCC)=O)COC(CCCCCCCCCCC)=O",
       scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
.cal_c(smi = "C(OCCCCCCCCCCCCC(C)C)C(OC(CCCCCCCCCCCC(C)C)=O)COC(=O)CCCCCCCCCCCC(C)C",
       scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
.cal_d(smi = "C(OC(=O)CCCCCCC/C=C\\\\CCCCCC)[C@]([H])(OC(CCCCCCC/C=C\\\\CCCCCC)=O)COC(CCCCCCC/C=C\\\\CCCCCC)=O",
       scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
.cal_h(smi = "C(CC/C=C\\\\C/C=C\\\\CC(O)C(O)C/C=C\\\\C/C=C\\\\C/C=C\\\\CC)(=O)O",
       min_C = 1, max_C = 24,
       scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
.cal_n(smi = "C(OC(=O)CCCCCCCCCCCCCC(O)CCC)[C@]([H])(OC(CCCCCC(O)CC(O)CCCCCCC)=O)COC(CCCCCCCCCCC)=O",
       scriptPath = system.file("python", "SMARTS.py", package = "LipRtPred"))
}
